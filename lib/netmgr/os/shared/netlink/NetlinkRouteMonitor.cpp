/*
 *  Copyright 2019 Carnegie Technologies
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#include "NetlinkRouteMonitor.hpp"
#include "NetlinkMsgCreator.hpp"

using namespace Pravala;

NetlinkRouteMonitor::Owner::~Owner()
{
}

NetlinkRouteMonitor::NetlinkRouteMonitor ( NetlinkRouteMonitor::Owner & owner, uint32_t mcastGroups ):
    NetlinkAsyncSocket ( NetlinkCore::Route, mcastGroups ),
    _owner ( owner )
{
}

void NetlinkRouteMonitor::netlinkMCastSocketFailed()
{
    _owner.netlinkRouteMonitorFailed ( this );
}

void NetlinkRouteMonitor::netlinkReqFailed ( uint32_t reqSeqNum, ERRCODE errorCode )
{
    _owner.netlinkRouteReqFailed ( this, reqSeqNum, errorCode );
}

uint32_t NetlinkRouteMonitor::getLinks()
{
    NetlinkMessage msg ( NetlinkMsgCreator::createRtmGetLink() );
    return sendMessage ( msg );
}

uint32_t NetlinkRouteMonitor::getAddresses ( IpAddress::AddressType addrType )
{
    NetlinkMessage msg ( NetlinkMsgCreator::createRtmGetAddr ( addrType ) );
    return sendMessage ( msg );
}

uint32_t NetlinkRouteMonitor::getRoutes ( uint8_t rtTable )
{
    NetlinkMessage msg ( NetlinkMsgCreator::createRtmGetRoute ( rtTable ) );
    return sendMessage ( msg );
}

void NetlinkRouteMonitor::netlinkReceived ( List<NetlinkMessage> & messages )
{
    NetlinkRoute::RouteResults routeResults;

    uint32_t seqNum = 0;
    uint32_t nlPid = 0;
    bool hasError = false;
    struct nlmsgerr msgError;

    memset ( &msgError, 0, sizeof ( msgError ) );

    for ( size_t i = 0; i < messages.size(); ++i )
    {
        const uint32_t msgSeqNum = messages.at ( i ).getSeqNum();

        if ( nlPid == 0 )
        {
            nlPid = messages.at ( i ).getPid();
        }

        if ( msgSeqNum != 0 )
        {
            if ( seqNum == 0 )
            {
                seqNum = msgSeqNum;
            }
            else if ( seqNum != msgSeqNum )
            {
                // There is no good way of handling it...

                LOG ( L_FATAL_ERROR, "Invalid sequence numbers in a multipart Netlink message; Expected SeqNum: "
                      << seqNum << "; Received: " << msgSeqNum );
            }
        }

        if ( !hasError )
        {
            const struct nlmsgerr * const mErr = messages.at ( i ).getError();

            if ( mErr != 0 )
            {
                hasError = true;
                msgError = *mErr;
            }
        }

        const struct nlmsghdr * const hdr = messages.at ( i ).getNlmsghdr();

        ( void ) hdr;

        LOG ( L_DEBUG4, "Processing 'route' message part; Type: " << hdr->nlmsg_type
              << "; Flags: " << hdr->nlmsg_flags << "; SeqNum: " << hdr->nlmsg_seq
              << "; PID: " << hdr->nlmsg_pid << "; Length: " << hdr->nlmsg_len );

        NetlinkRoute::parseRouteMessage ( messages.at ( i ), routeResults );
    }

    // We may be waiting for a message with a specific sequence number.
    // This sequence number only matters if we generated the request.
    // If this message is sent in a response to a requested generated by some other socket
    // (with a different PID), it doesn't really matter what the sequence number is.
    // So we unset (set to 0) the sequence number if this message is a result of another socket's request.

    if ( seqNum != 0 && nlPid != _sockPID )
    {
        LOG ( L_DEBUG2, "Received Netlink message was generated by a different socket; Our PID: "
              << _sockPID << "; Received PID: " << nlPid << "; SequenceNumber: " << seqNum
              << "; Setting sequence number to 0" );

        seqNum = 0;
    }

    LOG ( L_DEBUG2, "Reporting route results to owner" );

    _owner.netlinkRcvRouteResults ( this, seqNum, ( hasError ) ? ( &msgError ) : ( 0 ), routeResults );
}
