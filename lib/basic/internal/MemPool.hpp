/*
 *  Copyright 2019 Carnegie Technologies
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#pragma once

extern "C"
{
#include <stdint.h>
}

#include <cstdlib>

#include "../Mutex.hpp"
#include "../MsvcSupport.hpp"

#include "MemBlock.hpp"

namespace Pravala
{
/// @brief Base class for memory pools.
class MemPool
{
    public:
        /// @brief The default payload offset used by the MemPool.
        static const size_t DefaultPayloadOffset = sizeof ( PoolMemBlock );

        /// @brief The size (in bytes) of payload in each block that is a part of this pool.
        /// @note This does NOT include the block header.
        const size_t PayloadSize;

        /// @brief The offset (in bytes) after the beginning of each block at which the payload memory starts.
        const size_t PayloadOffset;

        /// @brief Returns the number of free blocks in the pool.
        /// @note Even if it returns zero, it doesn't mean that the pool will fail to allocate more blocks.
        ///       This pool may be capable of allocating more memory and adding more blocks if required.
        /// @return The number of free blocks in the pool.
        inline size_t getFreeBlocksCount() const
        {
            return _freeBlocksCount;
        }

        /// @brief Returns the number of blocks allocated by the pool so far.
        /// This includes both used and free blocks.
        /// @return The number of blocks allocated by the pool so far.
        inline size_t getAllocatedBlocksCount() const
        {
            return _allocatedBlocksCount;
        }

    protected:

        Mutex _mutex; ///< Mutex protecting this memory pool.

        /// @brief Pointer to first free block.
        /// If the pointer is 0, there are no free blocks left.
        PoolMemBlock * _poolHead;

        /// @brief The number of free blocks in the list.
        size_t _freeBlocksCount;

        /// @brief The number of allocated blocks.
        size_t _allocatedBlocksCount;

        /// @brief Set to 'true' when the memory pool is shutting down.
        /// This will cause it to be destroyed when the 'free' count reaches 'allocated' count.
        bool _isShuttingDown;

        /// @brief Constructor.
        /// @param [in] payloadSize The size (in bytes) of payload data in each block that is a part of this pool
        ///                       (NOT including the block header). This value will be stored in PayloadSize constant.
        ///                       It is not used or needed by this class itself, but it signifies the fact that
        ///                       all blocks within the pool need to use the same size. While copying data,
        ///                       MemHandle assumes that blocks generated by the same pool can store at least
        ///                       as much data as the blocks being copied.
        /// @param [in] payloadOffset The offset (in bytes) after the beginning of each block at which the payload
        ///                           memory starts. It MUST be at least the size of PoolMemBlock, AND a multiple of 4!
        MemPool ( size_t payloadSize, size_t payloadOffset = DefaultPayloadOffset );

        /// @brief Destructor.
        virtual ~MemPool();

        /// @brief Shuts down the memory pool.
        /// It will not generate any new blocks.
        /// Also, once the last used block is returned to it, it will call the destructor.
        /// Finally, if this pool is not used, the destructor will be called inside this call.
        virtual void shutdown();

        /// @brief Returns a memory block from the pool.
        /// @return Memory block to use, or 0 if the pool is empty.
        ///         Returned block will have a reference counter set to 1.
        inline PoolMemBlock * getBlock()
        {
            _mutex.lock();

            if ( _isShuttingDown )
            {
                _mutex.unlock();
                return 0;
            }

            if ( !_poolHead )
            {
                addMoreBlocks();

                if ( !_poolHead )
                {
                    _mutex.unlock();
                    return 0;
                }
            }

            assert ( _poolHead != 0 );

            PoolMemBlock * const block = _poolHead;
            _poolHead = block->u.next;

            assert ( _freeBlocksCount > 0 );

            --_freeBlocksCount;

            _mutex.unlock();

            assert ( block->getRefCount() > 0 );

            block->u.memPool = this;

            return block;
        }

        /// @brief Returns given block back to the pool.
        /// Should be called when the block is no longer used.
        /// @note This could destroy the pool (if it's shutting down and the block released was the last used one).
        /// @param [in] block The block to return to the pool. It must be valid and belong to this pool.
        ///                   It also MUST have the reference (re)set to 1!
        ///                   This is so the next time it's taken from the pool, it has that single reference!
        inline void releaseBlock ( PoolMemBlock * block )
        {
            if ( !block )
                return;

            if ( block->getRefCount() != 1 || block->u.memPool != this )
            {
                // Since we always check anyway, let's assert inside.
                // Also, assert on a specific thing, not on 'false' - so that we know what happened.

                assert ( block->getRefCount() == 1 );
                assert ( block->u.memPool == this );

                // We will leak memory, but it's probably better than crashing horribly later...
                return;
            }

            _mutex.lock();

            block->u.next = _poolHead;
            _poolHead = block;

            ++_freeBlocksCount;

            if ( _isShuttingDown && _freeBlocksCount >= _allocatedBlocksCount )
            {
                _mutex.unlock();
                delete this;
                return;
            }

            _mutex.unlock();
        }

        /// @brief Internal function used to add more blocks to the pool once it becomes empty.
        /// Default implementation doesn't do anything.
        /// @warning This function is called with the mutex LOCKED. The mutex is expected to still
        ///          be locked after it returns, but it may be unlocked and re-locked inside.
        virtual void addMoreBlocks();

        friend struct MemBlock;
        friend struct MemData;
};
}
