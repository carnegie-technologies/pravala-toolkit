/*
 *  Copyright 2019 Carnegie Technologies
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

extern "C"
{
#include <linux/vhost.h>
}

#include <cassert>

#include "../../../PacketDataStore.hpp"
#include "RxVring.hpp"

using namespace Pravala;

RxVring::RxVring ( uint16_t maxDescs, uint8_t memTag ): Vring ( maxDescs, memTag )
{
}

ERRCODE RxVring::setup ( int vhostFd, int backendFd )
{
    ERRCODE eCode = internalSetup ( RxVringIdx, vhostFd, backendFd );

    if ( eCode == Error::AlreadyInitialized )
    {
        // You really shouldn't be messing with an already initialized object
        assert ( false );

        return eCode;
    }

    if ( NOT_OK ( eCode ) )
    {
        clear();
        return eCode;
    }

    assert ( _ring != 0 );
    assert ( getVheaderLen() > 0 );

    for ( uint16_t idx = 0; idx < MaxDescs; idx += 2 )
    {
        // We always use descriptors 2 at a time.
        // First descriptor for the virtio header.
        // Second descriptor for the actual packet (i.e. IP packet or ethernet frame).

        assert ( idx % 2 == 0 );

        // The first is always chained to the next one.
        // Set up those fields now.
        _ring->desc[ idx ].flags = VRING_DESC_F_WRITE | VRING_DESC_F_NEXT;
        _ring->desc[ idx ].len = getVheaderLen();

        const uint16_t idx2 = idx + 1;

        assert ( idx2 < MaxDescs );

        _ring->desc[ idx ].next = idx2;

        _ring->desc[ idx2 ].flags = VRING_DESC_F_WRITE;
    }

    refill();

    return eCode;
}

bool RxVring::refill()
{
    // If the avail ring idx is the same as the used ring idx, that means that the system has used up all the available
    // descriptors and will not try to give us more data until we kick it again.
    const bool needKick = ( _ring->avail->idx == _ring->used->idx );

    LOG ( L_DEBUG4, "freeDescs: " << _freeDescs << "; availIdx: " << _ring->avail->idx
          << "; usedIdx: " << _ring->used->idx << "; needKick: " << needKick );

    assert ( _freeDescs <= MaxDescs );
    assert ( _freeDescs % 2 == 0 ); // We always use them 2 at a time

    for ( ; _freeDescs >= 2; )
    {
        const uint16_t idx1 = _nextDescIdx;
        const uint16_t idx2 = ( idx1 + 1 ) % MaxDescs;

        // We always add 2 descriptors at a time, so idx1 should be even
        assert ( idx1 % 2 == 0 );

        assert ( idx1 < MaxDescs );
        assert ( idx2 < MaxDescs );

        assert ( _ring->desc[ idx1 ].flags == ( VRING_DESC_F_WRITE | VRING_DESC_F_NEXT ) );
        assert ( _ring->desc[ idx1 ].next == idx2 );

        assert ( _ring->desc[ idx2 ].flags == VRING_DESC_F_WRITE );

        _descMH[ idx1 ] = PacketDataStore::getPacket ( getVheaderLen() );
        _descMH[ idx2 ] = PacketDataStore::getPacket();

        assert ( getVheaderLen() > 0 );

        if ( _descMH[ idx1 ].size() < getVheaderLen() || _descMH[ idx2 ].isEmpty() )
        {
            _descMH[ idx1 ].clear();
            _descMH[ idx2 ].clear();

            LOG ( L_FATAL_ERROR, "Failed to get memory to refill RX ring" );
            break;
        }

        if ( !canUseMemory ( _descMH[ idx1 ] ) || !canUseMemory ( _descMH[ idx2 ] ) )
        {
            // If PacketDataStore is out of "data store" memory, it will generate regular memory.
            // We cannot use that :(

            _descMH[ idx1 ].clear();
            _descMH[ idx2 ].clear();

            LOG ( L_FATAL_ERROR, "Could not refill RX ring; Wrong memory type generated by PacketDataStore" );
            break;
        }

        assert ( canUseMemory ( _descMH[ idx1 ] ) );
        assert ( canUseMemory ( _descMH[ idx2 ] ) );

        // first desc is used for the header, so truncate it to the length of the header
        _descMH[ idx1 ].truncate ( getVheaderLen() );

        char * const w1 = _descMH[ idx1 ].getWritable();
        char * const w2 = _descMH[ idx2 ].getWritable();

        if ( !w1 || !w2 )
        {
            _descMH[ idx1 ].clear();
            _descMH[ idx2 ].clear();

            LOG ( L_ERROR, "Failed to get memory to refill RX ring" );
            break;
        }

        _ring->desc[ idx1 ].addr = ( uint64_t ) w1;

        // We set up the first descriptor's length to be equal to vheaderLen then truncated it above,
        // so the length should still be equal to vheaderLen
        assert ( _ring->desc[ idx1 ].len == getVheaderLen() );
        assert ( _ring->desc[ idx1 ].len == _descMH[ idx1 ].size() );

        // getWritable shouldn't have changed the packet type
        assert ( canUseMemory ( _descMH[ idx1 ] ) );

        _ring->desc[ idx2 ].addr = ( uint64_t ) w2;
        _ring->desc[ idx2 ].len = _descMH[ idx2 ].size();

        // getWritable shouldn't have changed the packet type
        assert ( canUseMemory ( _descMH[ idx2 ] ) );

        assert ( _ring->desc[ idx1 ].addr != 0 );
        assert ( _ring->desc[ idx2 ].addr != 0 );

        _nextDescIdx += 2;
        _nextDescIdx %= MaxDescs;

        assert ( _freeDescs >= 2 );

        _freeDescs -= 2;

        _ring->avail->ring[ _ring->avail->idx % MaxDescs ] = idx1;
        ++_ring->avail->idx;

        // We don't need to check if the available ring has enough free indexes, since it's not possible
        // to have free descriptors and not have free elements in the available ring.

        LOG ( L_DEBUG4, "Added descs to RX. idx1: " << idx1 << "; idx2: " << idx2
              << "; final availIdx: " << _ring->avail->idx
              << "; final nextDescIdx: " << _nextDescIdx
              << "; freeDescs: " << _freeDescs );
    }

    return needKick;
}

ERRCODE RxVring::readPacket ( MemHandle & vhdr, MemHandle & data )
{
    const uint16_t ringIdx = vring_used_event ( _ring ) % MaxDescs;

    LOG ( L_DEBUG4, "vring_used_event: " << vring_used_event ( _ring ) << "; ringIdx: " << ringIdx
          << "; usedIdx: " << _ring->used->idx );

    // If we already processed the last descriptor head the system used, then there's nothing to read
    if ( vring_used_event ( _ring ) == _ring->used->idx )
    {
        return Error::SoftFail;
    }

    // Descriptor index that contains the virtio header
    const uint16_t descIdxVH = _ring->used->ring[ ringIdx ].id;

    assert ( descIdxVH < MaxDescs );

    // Descriptor index that contains the payload data (i.e. the "next" segment after descIdxVH)
    const uint16_t descIdxData = _ring->desc[ descIdxVH ].next;

    assert ( descIdxData < MaxDescs );

    // With the way we set it up, descIdxData should always be the desc after descIdxVH, and adding 1 to descIdxVH
    // should never wrap around (since we allocate them in pairs with descIdxVH as the first one of the pair,
    // and MaxDescs has to be a power of 2).
    assert ( ( descIdxVH + 1 ) < MaxDescs );
    assert ( descIdxData == ( descIdxVH + 1 ) );

    uint32_t len = _ring->used->ring[ ringIdx ].len;

    if ( len < 1 )
    {
        // On SMP systems, it's possible that we got the event before the data appeared, try again later

        LOG ( L_DEBUG4, "No data" );

        // We don't want to clean the descriptor in this case!
        return Error::EmptyRead;
    }

    LOG ( L_DEBUG4, "descIdxVH: " << descIdxVH << "; descIdxData: " << descIdxData << "; ringIdx: " << ringIdx
          << "; availIdx: " << _ring->avail->idx << "; nextDescIdx: " << _nextDescIdx
          << "; freeDescs: " << _freeDescs << "; usedIdx: " << _ring->used->idx
          << "; vring_used_event: " << vring_used_event ( _ring ) );

    vhdr = _descMH[ descIdxVH ];
    _descMH[ descIdxVH ].clear();

    data = _descMH[ descIdxData ];
    _descMH[ descIdxData ].clear();

    _freeDescs += 2;

    assert ( _freeDescs <= MaxDescs );

    // At this point, the packet is "valid" from a descriptor point of view, so we should clean it
    // from the ring. We still need to check if it's actually long enough.

    // We cleaned a used descriptor head from the ring, increment the counter.
    // This tells the system it should notify us when a new packet is available.
    // vring_used_event is actually macro, so this works...
    ++( vring_used_event ( _ring ) );

    if ( vhdr.size() >= len )
    {
        vhdr.clear();
        data.clear();

        LOG ( L_ERROR, "Got incomplete packet" );

        return Error::IncompleteData;
    }

    len -= vhdr.size();

    data.truncate ( len );

    if ( data.isEmpty() )
    {
        vhdr.clear();
        data.clear();

        LOG ( L_ERROR, "Got packet with empty payload" );

        return Error::IncompleteData;
    }

    return Error::Success;
}
