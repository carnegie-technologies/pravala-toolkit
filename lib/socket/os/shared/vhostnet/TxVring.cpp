/*
 *  Copyright 2019 Carnegie Technologies
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

extern "C"
{
#include <linux/vhost.h>
}

#include <cassert>

#include "../../../PacketDataStore.hpp"
#include "TxVring.hpp"

// Helper macro to make sure a MemHandle isn't empty and is from PacketDataStore
#define CHECK_MEMHANDLE( mh ) \
    do { \
        if ( mh.isEmpty() ) { return Error::EmptyWrite; } \
        if ( !canUseMemory ( mh ) ) { return Error::InvalidParameter; } \
    } while ( false )

// Helper macro to make sure a MemHandle is the same size as the virtio header length and is from PacketDataStore
#define CHECK_MEMHANDLE_VHDR( mh ) \
    do { \
        if ( mh.size() != getVheaderLen() ) { return Error::IncompleteData; } \
        if ( !canUseMemory ( mh ) ) { return Error::InvalidParameter; } \
    } while ( false )

using namespace Pravala;

TxVring::TxVring ( uint16_t maxDescs, uint8_t memTag ): Vring ( maxDescs, memTag )
{
}

ERRCODE TxVring::setup ( int vhostFd, int backendFd )
{
    ERRCODE eCode = internalSetup ( TxVringIdx, vhostFd, backendFd );

    if ( eCode == Error::AlreadyInitialized )
    {
        // You really shouldn't be messing with an already initialized object
        assert ( false );

        return eCode;
    }

    if ( NOT_OK ( eCode ) )
    {
        clear();
        return eCode;
    }

    assert ( getVheaderLen() > 0 );

    _zeroVheader = PacketDataStore::getPacket ( getVheaderLen() );

    if ( !canUseMemory ( _zeroVheader ) )
    {
        // If PacketDataStore is out of "data store" memory, it will generate regular memory.
        // We cannot use that :(

        LOG ( L_FATAL_ERROR, "Failed to allocate memory for virtio header; "
              "Wrong memory type generated by PacketDataStore" );

        _zeroVheader.clear();
        clear();
        return Error::MemoryError;
    }

    assert ( canUseMemory ( _zeroVheader ) );

    if ( _zeroVheader.size() < getVheaderLen() )
    {
        LOG ( L_FATAL_ERROR, "Failed to allocate memory for virtio header" );

        clear();
        return Error::MemoryError;
    }

    _zeroVheader.truncate ( getVheaderLen() );
    char * const w = _zeroVheader.getWritable();

    if ( !w )
    {
        LOG ( L_ERROR, "Failed to allocate memory for virtio header" );

        clear();
        return Error::MemoryError;
    }

    memset ( w, 0, _zeroVheader.size() );

    LOG ( L_DEBUG, "Set up TxVring with vheader length: " << _zeroVheader.size()
          << "; vhostFd: " << vhostFd << "; backendFd: " << backendFd );

    return eCode;
}

bool TxVring::cleanUsed()
{
    LOG ( L_DEBUG4, "(start) availIdx: " << _ring->avail->idx << "; usedIdx: " << _ring->used->idx
          << "; nextDescIdx: " << _nextDescIdx << "; freeDescs: " << _freeDescs
          << "; vring_used_event: " << vring_used_event ( _ring ) );

    // Loop while we have not processed all used decriptor heads (i.e. elements in the used ring)
    // See Vring.cpp for more about vring_used_event()
    while ( vring_used_event ( _ring ) != _ring->used->idx )
    {
        const uint16_t ringIdx = vring_used_event ( _ring ) % MaxDescs;

        // Descsriptor head index
        uint16_t descIdx = _ring->used->ring[ ringIdx ].id;

        // Clear the actual descriptors (i.e. the objects that are linked to memory)
        bool hasNext = false;

        do
        {
            assert ( descIdx < MaxDescs );

            hasNext = ( _ring->desc[ descIdx ].flags & VRING_DESC_F_NEXT ) == VRING_DESC_F_NEXT;

            _descMH[ descIdx ].clear();

            // Since we set it up, if we have a next segment it should be the next index
            assert ( !hasNext || _ring->desc[ descIdx ].next == ( ( descIdx + 1 ) % MaxDescs ) );

            descIdx = _ring->desc[ descIdx ].next;

            ++_freeDescs;

            assert ( _freeDescs <= MaxDescs );
        }
        while ( hasNext );

        // We cleaned a used descriptor head from the ring, increment the counter.
        // vring_used_event ( _ring ) is actually a macro that returns a writable reference, so this works.
        ++( vring_used_event ( _ring ) );

        LOG ( L_DEBUG4, "(loop) availIdx: " << _ring->avail->idx << "; usedIdx: " << _ring->used->idx
              << "; nextDescIdx: " << _nextDescIdx << "; freeDescs: " << _freeDescs
              << "; vring_used_event: " << vring_used_event ( _ring ) );
    }

#ifndef NDEBUG
    if ( _freeDescs < MaxDescs )
    {
        // Since there are some descs that aren't free, the avail idx (things we offered to the system)
        // should not be equal to the next index we should clean.
        assert ( vring_used_event ( _ring ) != _ring->avail->idx );

        // We should not assert here against the used ring's index since that may have changed
        // since we left the loop above.
    }
    else
    {
        // There should never be more free descs than MaxDescs, so ths only possibility should be that
        // all descs are free.
        assert ( _freeDescs == MaxDescs );

        // This should be equal since we cleaned everything we offered.
        assert ( vring_used_event ( _ring ) == _ring->avail->idx );

        // This should also be equal since we cleaned everything we offered.
        // This is also safe since the system shouldn't be using anything (as we didn't offer anything).
        assert ( vring_used_event ( _ring ) == _ring->used->idx );
    }
#endif

    // If we consumed everything, return true
    return ( _freeDescs == MaxDescs );
}

uint16_t TxVring::append ( const MemHandle & mh, bool last )
{
    assert ( _freeDescs > 0 );
    assert ( _freeDescs <= MaxDescs );
    assert ( _nextDescIdx < MaxDescs );
    assert ( !mh.isEmpty() );

    const uint16_t desc = _nextDescIdx;

    _descMH[ desc ] = mh;
    _ring->desc[ desc ].addr = ( uint64_t ) _descMH[ desc ].get();
    _ring->desc[ desc ].len = _descMH[ desc ].size();

    if ( !last )
    {
        _ring->desc[ desc ].flags = VRING_DESC_F_NEXT;
        _ring->desc[ desc ].next = desc + 1;
    }
    else
    {
        _ring->desc[ desc ].flags = 0;

        // The next field is ignored by the system when VRING_DESC_F_NEXT isn't set,
        // so we don't need to update it.
    }

    --_freeDescs;

    LOG ( L_DEBUG4, "TX added descriptor at idx: " << desc
          << "; Packet Length: " << mh.size() << "; Free descs: " << _freeDescs );

    ++_nextDescIdx;
    _nextDescIdx %= MaxDescs;

    return desc;
}

void TxVring::offer ( uint16_t index )
{
    assert ( index < MaxDescs );

    const uint16_t ringIdx = _ring->avail->idx % MaxDescs;

    _ring->avail->ring[ ringIdx ] = index;
    ++_ring->avail->idx;

    LOG ( L_DEBUG4, "TX offered packet at ringIdx: " << ringIdx << "; Descriptor head: " << index );

    // We don't need to check if the available ring has enough free indexes, since it's not possible
    // to have free descriptors and not have free elements in the available ring.
}

ERRCODE TxVring::writeData ( const MemHandle & vhdr, const MemHandle & data )
{
    if ( _freeDescs < 2 )
        return Error::SoftFail;

    CHECK_MEMHANDLE_VHDR ( vhdr );
    CHECK_MEMHANDLE ( data );

    const uint16_t firstIdx = append ( vhdr, false );
    append ( data, true );
    offer ( firstIdx );

    return Error::Success;
}

ERRCODE TxVring::writeData ( const MemHandle & vhdr, const MemVector & data )
{
    const size_t numChunks = data.getNumChunks();

    if ( _freeDescs < 1 + numChunks )
        return Error::SoftFail;

    CHECK_MEMHANDLE_VHDR ( vhdr );

    // CHECK_MEMHANDLE works on MemVector too (without conversion):
    CHECK_MEMHANDLE ( data );

    const uint16_t firstIdx = append ( vhdr, false );

    for ( size_t i = 0; i < numChunks; ++i )
    {
        append ( data.getChunk ( i ), ( i + 1 >= numChunks ) );
    }

    offer ( firstIdx );

    return Error::Success;
}
