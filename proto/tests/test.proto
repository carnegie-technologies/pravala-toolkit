
# Some additional .proto files, that were used for testing various
# aspects of the protocol during the development:
import "other/all.proto";

namespace Test
{

struct ValueStore
{
    optional  int8  signed_a   : 1;
    optional  int16 signed_b   : 2;
    optional  int32 signed_c   : 3;
    optional  int64 signed_d   : 4;

    optional uint8  unsigned_a : 11;
    optional uint16 unsigned_b : 12;
    optional uint32 unsigned_c : 13;
    optional uint64 unsigned_d : 14;

    optional  float floating_a : 20;
    optional double floating_b : 21;
}

message ValueMessage
{
    repeated ValueStore values : 9;
}

namespace General
{
// An example of an enumerator
// With a comment
enum TestCode
{
    // One of the entries of the enum
    code_a = 1;
    code_b = 2; // Another comment, for 'code_c'
    code_c = 3;
    code_invalid = 99 [ default ];
}

// This is a base message
// It has automatically added 'length' field
message BaseMsg
{
    // We use this for determining specific message types
    protected unique required uint16 type : 1;

    optional string msg_type_name : 2 [ default = "not-set" ]; // we can use this to store the name of the message

    # It has to be protected to be aliased by other fields that are defined by other messages!
    protected optional uint32 config : 3; // storage type for configuration bits

    # This one is similar, but is 'false' by default.
    # Only one thing can define it to be 'true', nothing can define it to be 'false'
    protected unique alias is_ctrl : config [ 2 ]; // Whether this is a control message or not

    public optional timestamp timestamp : 99; // Timestamp
}

}

// Control messages
namespace Ctrl
{

// To be inherited by ALL control messages.
// the only purpose is to define the is_ctrl bit!
message CtrlMsg(General.BaseMsg)
{
    defined is_ctrl = true;

    alias is_remote : config[0]; // One bit for marking remote messages

    // One bit for marking pub sub messages
    // It is implictely defined as 'false'.
    // It is also marked as 'unique', which means that only
    // one message can define it to be 'true'. Since the default is 'false'
    // no message can 'define' it to 'false;
    // It has to be protected to be defined by other messages!
    protected unique alias is_pub_sub : config[1];

    // Whether this message is a response or not.
    protected unique alias is_response : config [ 3 ];

    alias src_addr : config [ 4 - 11 ]; // 8 bits for the 'source' address
    alias dst_addr : config [ 12 - 19 ]; // 8 bits for the 'dest' addresses

    # This comment will not be a part of generated code.
    # Comments that start with '//' are added to declarations of the elements
    # in the autogenerated code. Comments that start with '#' are not, those
    # are comments that apply only to the protocol definition file itself!

    # Here we create another alias to part of 'config'
    // Determines whether the message should be sent over reliable channel or not
    alias is_unreliable : config[20];

    # Special aliases, that use one extra bit for the presence field:
    salias settable_bit : config[22];
    salias settable_field : config[24-31];
}

// To be inherited by ALL ctrl message response messages
// defines is_response bit
message CtrlRespMsg(CtrlMsg)
{
    defined is_response = true;
}

// To be inherited by all pub-sub request messages
// defines is_pub_sub bit, and also includes some pub-sub data
message PubSubReq(CtrlMsg)
{
    defined is_pub_sub = true;

    // The type of the subscription
    required uint8 subType : 4;

    // The target of the subscription, not required
    optional uint16 subTarget : 5;

    // The type of the condition
    optional uint8 condType : 6;

    // Some additional payload, optional
    optional uint8 extra : 7;
}

message PubSubResp(CtrlRespMsg)
{
    # Here we can't inherit PubSubReq, because we want to
    # be marked as 'response', so we need CtrlRespMsg.
    # We can't define is_pub_sub directly, but we can do it this
    # way:

    defined is_pub_sub as_in PubSubReq;

    // Some additional payload, optional
    optional uint8 extra : 7; # We can re-use code 7 as long as --id-scope is set to 'branch'.
}

typedef IfaceId(int8);

message PubSubReqIfaceState(PubSubReq)
{
    defined type = 2;

    # The autogenerated code will also check if the ID is valid (at least 1)
    required IfaceId iface_id : 8 [ min = 1 ];
}

struct IfaceIdMessage
{
    # Not that this makes sense... but just for testing!
    # This field also shows the lack of 'bool' type.
    # 'bool' gives the false impression that it's just 1 bit.
    # Unfortunately it is not and we prefer people to know what they're
    # doing. For storing one bit we need to group those bits together,
    # use aliases and put them inside other storage type.
    # Here we waste 7 bits, but at least it's clear that we are doing that.
    required protected unique uint8 is_iface_id_msg : 1;

    required IfaceId iface_id : 2 [ min = 1 ];
}

struct IfaceDesc(IfaceIdMessage)
{
    defined is_iface_id_msg = 1;

    // Different states of the interface
    enum IfaceStatus
    {
        # The internal value of the enumerator will be set to the value
        # declared with the 'default' option when clear() is called.
        # There has to be exactly one element declared as 'default'.
        IfaceNotPresent = 0 [ default ];

        IfaceDown = 1;
        IfaceUp = 2;
    }

    required IfaceStatus ifaceStatus : 3;
}

message PubSubRespIfaceState(PubSubResp)
{
    defined type = 3;

    repeated IfaceDesc ifaceDesc : 8 [ min_list_size = 1 ];
}

struct PubSubRespContainer
{
    required General.BaseMsg base_psub_resp   : 1;
    optional General.BaseMsg base_psub_resp_2 : 2;
    repeated General.BaseMsg base_psub_resp_3 : 3;
}

// 'Hello' message sent to the server
message ClientHello(General.BaseMsg)
{
   defined type = 4;

   # This field is not only required, but we can also tell the protocol code to
   # check if its length is in specific range!
   required string cert_id : 5 [ min_length = 5, max_length = 30 ];
}

message ClientConfig(General.BaseMsg)
{
   defined type = 5;

   # This type is an extension type added by 'Pravala' generator
   # We also set 'min_list_size' option - the autogenerated code will check whether there
   # is at least one element in the list!
    // The list of IP addresses for the client to use as it's tunnel address
   repeated ip_addr addrToUse : 5 [ min_list_size = 1 ];

   # Here we pass DNS address as a string (just as an example).
   # We don't force this list ot have any elements,
   # but if it does, each of them will have to have at least 8 characters!
   # (like '8.8.8.8')
   // The list of DNS servers to use
   repeated string dnsToUse : 6 [ min_length = 7 ];
}

message ClientRejected(General.BaseMsg)
{
   defined type = 6;

   required General.TestCode errCode : 5;
}

enum Command
{
    AppStatusReq = 0;
    AppStatusResp = 1;
    IfaceState = 2;
    IfaceControl = 3;
    IfaceQuality = 4;
    TrafficRulesReq = 5;
    TrafficRulesUpdate = 6;
    TrafficRulesApplied = 7;

    UnknownCommand = 999 [ default ];
}

enum Xyz
{
   A = 0 [ default ];
}

struct Abc
{
    protected unique required Command cmd_id : 1;
}

struct AppStatusReq(Abc)
{
    defined cmd_id = AppStatusReq;
}

struct AppStatusResp(Abc)
{
    defined cmd_id = AppStatusResp;

    required string app_list : 2;
}

}

message Container
{
    required General.BaseMsg base_msg : 1;
    optional General.BaseMsg base_msg_2 : 2;
    repeated General.BaseMsg base_msg_3 : 3;

    required Ctrl.IfaceDesc iface_desc : 4;
}

}
