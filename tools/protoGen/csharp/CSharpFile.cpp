/*
 *  Copyright 2019 Carnegie Technologies
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

#include <cstdio>
#include <cassert>

#include "CSharpFile.hpp"

using namespace Pravala;

CSharpFile::CommentTag::CommentTag (
        CSharpFile & myFile, const char * closingTagName, bool eolAfterTextA,
        const String & textA, const String & textB ):
    CommentBlock ( myFile, "///" ), _closingTag ( closingTagName )
{
    a ( textA );

    if ( eolAfterTextA )
        e();

    a ( textB );
}

CSharpFile::CommentTag::~CommentTag()
{
    if ( _numLines > 0 )
    {
        // This is a multi-line comment.
        // Add an EOL at the end of the output so far (if there is anything in the current line)

        if ( !_text.isEmpty() )
            e();

        // And append the closing tag
        a ( _closingTag );

        return;
    }

    // Single line comment.

    if ( _text.isEmpty() )
    {
        // This should not really happen, because we should have opened the tag!
        // But in case this really is an empty line, we need the comment prefix before closing the tag

        a ( _closingTag ).e();
        return;
    }

    // There is something in this line, so it includes the comment prefix.
    // Write that content, add closing tag and finish the line.
    _myFile.a ( _text ).a ( _closingTag ).e();
    _text.clear();
}

CSharpFile::CSharpFile ( const String & path, const String & singleIndent ):
    FileObject ( path, singleIndent )
{
    _secHeader = appendSection();
    _secBody = appendSection();
    _secFooter = appendSection();

    setBodySection();
}

CSharpFile::CommentTag CSharpFile::csum (
        const String & textA, const String & textB,
        const String & textC, const String & textD )
{
    e().e();
    return CommentTag ( *this, "</summary>", true, "<summary>",
                        String ( textA ).append ( textB ).append ( textC ).append ( textD ) );
}

CSharpFile::CommentTag CSharpFile::cdesc (
        const String & textA, const String & textB,
        const String & textC, const String & textD )
{
    return CommentTag ( *this, "</remarks>", true, "<remarks>",
                        String ( textA ).append ( textB ).append ( textC ).append ( textD ) );
}

CSharpFile::CommentTag CSharpFile::cret (
        const String & textA, const String & textB,
        const String & textC, const String & textD )
{
    return CommentTag ( *this, "</returns>", false,
                        String ( "<returns>" ).append ( textA ).append ( textB ).append ( textC ).append ( textD ) );
}

CSharpFile::CommentTag CSharpFile::cparam (
        const String & paramName,
        const String & textA, const String & textB,
        const String & textC, const String & textD )
{
    return CommentTag ( *this, "</param>", false,
                        String ( "<param name=\"" ).append ( paramName ).append ( "\">" )
                        .append ( textA ).append ( textB ).append ( textC ).append ( textD ) );
}

CSharpFile::CommentTag CSharpFile::cexc (
        const String & crefName,
        const String & textA, const String & textB,
        const String & textC, const String & textD )
{
    return CommentTag ( *this, "</exception>", false,
                        String ( "<exception cref=\"" ).append ( crefName ).append ( "\">" )
                        .append ( textA ).append ( textB ).append ( textC ).append ( textD ) );
}

FileObject & CSharpFile::c ( const String & value )
{
    if ( value.isEmpty() )
        return a ( "///" );

    return a ( "/// " ).a ( value );
}

void CSharpFile::genAutogenComment()
{
    ae ( "// <auto-generated>" );
    ae ( "// This file has been automatically generated." );
    ae ( "// Changes to this file may cause incorrect behaviour and will be lost if the code is regenerated." );
    ae ( "// </auto-generated>" );
}

void CSharpFile::addImport ( const String & path )
{
    if ( path == _path )
        return;

    if ( !_imports.contains ( path ) )
    {
        _imports.insert ( path );

        const int secId = getSectionId();

        setHeaderSection();

        a ( "using " ).a ( path ).a ( ";" ).e();

        setSection ( secId );
    }
}
